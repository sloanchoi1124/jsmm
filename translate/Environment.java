package translate;

/*
 * bodies of functions are built as _linked_ lists so that they may be "flattened" later more efficiently;
 * after that process they can be converted to array lists to allow for random access
 * 
 */

import java.util.Deque;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;

import static ast.Ast.Expression;
import ast.SymbolTable;
import ast.Type;
import static ir.Ir.IrStatement;
import static ir.Ir.NopIrStatement;
import static ir.Ir.IrFunction;
import util.Label;
import util.Pair;
import util.Temp;
import util.Uid;


class Environment implements EnvironmentIfc {
	
	private final SymbolTable symbolTable;
	private final int wordSize;
	private Map<Label, IrFunction> functionMap;
	private Deque<FunEnv> funStack;
	private Map<Uid, Temp> uidTempMap;
	private Map<Label, String> labelStringMap;
	private final Map<Uid, Type> expressionTypeMap; 
		
	private static class FunEnv {
		Label funLabel;
		List<Temp> parameters;
		List<IrStatement> body;
		Label bodyLabel, exitLabel;
		Temp returnTemp;
		Deque<String> nameStack;
		Deque<Pair<Label, Label>> loopStack;
		Label nextLabel;
		FunEnv(Label funLabel, List<Temp> parameters) {
			this.funLabel = funLabel;
			this.parameters = parameters;
			this.body = new LinkedList<IrStatement>();
			this.bodyLabel = new Label("" + funLabel, "body");
			this.exitLabel = new Label("" + funLabel, "exit");
			this.returnTemp = null;
			this.nameStack = new ArrayDeque<String>();
			this.loopStack = new ArrayDeque<Pair<Label,Label>>();
			this.nextLabel = null;
		}
	}
	
	public Environment(SymbolTable symbolTable, Map<Uid, Type> expressionTypeMap, int wordSize) { 
		this.symbolTable = symbolTable;
		this.wordSize = wordSize;
		this.funStack = new ArrayDeque<FunEnv>();
		this.functionMap = new TreeMap<Label, IrFunction>();
		this.uidTempMap = new HashMap<Uid,Temp>();
		this.labelStringMap = new TreeMap<Label, String>();
		this.expressionTypeMap = expressionTypeMap;
	}
	
	
	public SymbolTable getSymbolTable() {
		return symbolTable;
	}	
	
	
	public int getWordSize() {
		return wordSize;
	}


	public Label enterFunction(List<Temp> parameters) {
		String name;
		// the function's label is generated by considering the enclosing function
		// and the most recently pushed name on the name stack
		if (funStack.size() == 1) { // if this is the outer environment
			name = "";
		} else {
			name = funStack.peek().funLabel.toString();
		}
		if (funStack.peek().nameStack.isEmpty()) {
			name += "_lambda_"; // to indicate an anonymous function 
		} else {
			name += funStack.peek().nameStack.peek();
		}
		Label funLabel = new Label(name, "");
		funStack.push(new FunEnv(funLabel, parameters));
		return funLabel;
	}
	
	
	public void enterMain() {
		funStack.push(new FunEnv(new Label("main"), new ArrayList<Temp>()));
	}
	
	
	public void exitFunction() {
		if (funStack.peek().nextLabel != null) {
			add(new NopIrStatement());
		}
		FunEnv funEnv = funStack.pop();
		functionMap.put(funEnv.funLabel,
				new IrFunction(
						funEnv.funLabel,
						funEnv.parameters, 
						funEnv.body,
						funEnv.bodyLabel,
						funEnv.exitLabel, 
						funEnv.returnTemp));
	}
	
	
	public void add(IrStatement statement) {
		if (funStack.peek().nextLabel != null) {
			statement.label = funStack.peek().nextLabel;
			funStack.peek().nextLabel = null;
		}
		funStack.peek().body.add(statement);
	}
	
	
	public void pushLoop(Label begin, Label end) {
		funStack.peek().loopStack.push(new Pair<Label,Label>(begin, end));
	}
	
	
	public void popLoop() {
		funStack.peek().loopStack.pop();
	}
	
	
	public void pushName(String name) {
		funStack.peek().nameStack.push(name);
	}
	
	public void popName() {
		funStack.peek().nameStack.pop();
	}
	
	public Label getBegin() {
		if (!funStack.peek().loopStack.isEmpty()) {
			return funStack.peek().loopStack.peek().first;
		}
		else {
			return null;
		}
	}
	
	
	public Label getEnd() {
		if (!funStack.peek().loopStack.isEmpty()) {
			return funStack.peek().loopStack.peek().second;
		}
		else {
			return null;
		}
	}
	
	
	public void addTemp(Uid uid, Temp temp) {
		uidTempMap.put(uid, temp);
	}
	
	
	public Temp getTemp(Uid uid) {
		return uidTempMap.get(uid);
	}
	
	
	public void addString(Label label, String s) {
		labelStringMap.put(label, s);
	}
	
	
	public Map<Label,IrFunction> getFunctions() {
		return functionMap;
	}
	
	
	public Map<Label, String> getLabelStringMap() {
		return labelStringMap;
	}


	public Label getBodyLabel() {
		return funStack.peek().bodyLabel;
	}
	
	
	public Label getExitLabel() {
		return funStack.peek().exitLabel;
	}


	public Temp getReturnTemp() {
		return funStack.peek().returnTemp;
	}
	
	
	public void setLabel(Label label) {
		if (funStack.peek().nextLabel != null) {
			add(new NopIrStatement());
		}
		funStack.peek().nextLabel = label;
	}
	
	public void setReturn() {
		if (funStack.peek().returnTemp == null) {
			funStack.peek().returnTemp = new Temp();
		}
	}
	
	
	public Type getType(Expression e) {
		return expressionTypeMap.get(e.nodeId);
	}
	
	
	public boolean isStandard(Uid uid) {
		return symbolTable.getLocation(uid) == null;
	}
	
}
